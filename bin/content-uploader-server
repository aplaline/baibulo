#!/usr/bin/env node

var redis   = require('redis'); 
var express = require('express');
var app     = express();

// Enable streaming API on Redis
require('redis-streams')(redis);

// Parse arguments
var argv = require('minimist')(process.argv, {
  default: {
    port: 3001,
    prefix: 'content:',
    "redis-host": "localhost",
    "redis-port": 6379,
    "redis-user": null,
    "redis-password": undefined,
    "content-url": "http://localhost:3000"
  }
});

// Show help if requested
if (argv.h || argv.help) {
  console.log([
    'usage: content-uploader [options]',
    '',
    '  --port port                port to listen for incomming requests [3001]',
    '  --prefix prefix            prefix for Redis keys [/content]',
    '  --redis-host host          Redis host [127.0.0.1]',
    '  --redis-port port          Redis port [6379]',
    '  --redis-password password  Redis password [null]',
    '  --content-url url          Base URL of the content [http://localhost:3000]',
    '                             It is used to make links the list of content versions'
  ].join("\n"));
  process.exit(1);
}

// Create Redis client
var client  = redis.createClient(null, null, {
  host: argv["redis-host"],
  port: argv["redis-port"],
  password: argv["redis-password"],
  detect_buffers: true
});

app.put('*', function(req, res) {
  var path = req.path;

  var contentType = req.get('Content-Type');
  if (!contentType) {
    res.status(400).send('Missing Content-Type header');
    return;
  }

  var version = req.get('Version');
  if (!version) {
    res.status(400).send('Missing Version header');
    return;
  }

  console.log('PUT ' + path + ':' + version + ' (' + contentType + ')');

  var setContentType = new Promise(function(resolve) {
    client.set(argv.prefix + path + ':content-type:' + version, contentType, resolve);
  });

  var setContent = new Promise(function(resolve, reject) {
    req
      .pipe(client.writeStream(argv.prefix + path + ':' + version, 2147483647))
      .on('finish', resolve)
      .on('error', reject);
  });

  var setETag = new Promise(function(resolve, reject) {
    client.set(argv.prefix + path + ':etag:' + version, Date.now(), resolve);
  });

  Promise.all([ setContentType, setContent, setETag ]).then(function(result) {
    res.status(201).send(path + ':' + version + ' created\n');
  })
  .catch(function(error) {
    console.log(error)
    res.status(500).send(error);
  })
});

app.get("/:context", function(req, res) {
  var getAllVersions = new Promise(function(resolve, reject) {
    client.keys(argv.prefix + "/" + req.params.context + "/index.html:content-type:*", function(err, keys) {
      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          keys[i] = keys[i].substr(keys[i].lastIndexOf(":") + 1);
        }
        keys.sort();
        keys.reverse();
        resolve(keys);
      } else {
        reject({ code: 500, message: err });
      }
    });
  });

  var getCurrentVersion = new Promise(function(resolve, reject) {
    client.get(argv.prefix + "/" + req.params.context + ":current", function(err, current) {
      resolve(current);
    });
  });

  Promise.all([ getAllVersions, getCurrentVersion ])
    .then(function(data) {
      var versions = data[0];
      var current  = data[1];
      var response = "";
      response = "<!doctype html><html><body><h1>Versions for context /" + req.params.context + "</h1><ul>";
      for (var i = 0; i < versions.length; i++) {
        response += "<li><a href='" + argv["content-url"] + "/" + req.params.context + "?version=" + versions[i] + "'>" + versions[i] + "</a>" + (versions[i] == current ? " (current)" : "") + "</li>";
      }
      response += "</ul></body></html>";
      res.end(response);
    })
    .catch(function(e) {
      res.status(e.code).send(e.message);
    });
});

app.listen(argv.port);

console.log("Listening for requests on port " + argv.port + "\n");
