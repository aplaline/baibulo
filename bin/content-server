#!/usr/bin/env node

var redis   = require('redis');
var streams = require('redis-streams');
var express = require('express');
var app     = express();
var url     = require('url');

// Enable streaming API on Redis
streams(redis);

// Enable compression on responses
app.use(require('compression')());

// Parse arguments
var argv = require('minimist')(process.argv, {
  default: {
    port: 3000,
    prefix: 'content:',
    "redis-host": "localhost",
    "redis-port": 6379,
    "redis-user": null,
    "redis-password": undefined
  }
});

// Show help if requested
if (argv.h || argv.help) {
  console.log([
    'usage: content-server [options]',
    '',
    '  --port port                port to listen for incomming requests [3000]',
    '  --prefix prefix            prefix for Redis keys [/content/]',
    '  --redis-host host          Redis host [127.0.0.1]',
    '  --redis-port port          Redis port [6379]',
    '  --redis-password password  Redis password [null]',
  ].join("\n"));
  process.exit(1);
}

// Create Redis client
var client = redis.createClient(null, null, {
  host: argv["redis-host"],
  port: argv["redis-port"],
  password: argv["redis-password"],
  detect_buffers: true
});

// Extract version specified in request
function extractRequestVersion(req) {
  return new Promise(function(resolve, reject) {
    // extract version number from Referer header
    var referer = req.header("Referer") ? url.parse(req.header("Referer"), true).query.version : null;
    // get specified version in Referer header or query parameter
    var result = referer || (req.query && req.query.version);
    if (result) {
      resolve(result);
    } else {
      reject();
    }
  });
}

// Get value from Redis
function get(key) {
  return new Promise(function(resolve, reject){
    client.get(argv.prefix + key, function(err, value) {
      if (value) {
        resolve(value);
      } else {
        reject({ code: 404, message: "Not found", redis: argv.prefix + key });
      }
    });
  });
}

// Extract context path
function extractContext(path) {
  var slash = path.indexOf("/", 1);
  return path.substr(0, slash == -1 ? undefined : slash);
}

// Extract path within the expected context
function extractPath(req) {
  var path = req.path;
  var ctx = extractContext(path)
  return ctx == path || path.endsWith("/") ? ctx + "/index.html" : path;
}

app.get('*', function(req, res) {
  var request = { version: 0, contentType: "" };
  var path    = extractPath(req);

  extractRequestVersion(req)
    .catch(function(error) {
      return get(extractContext(path) + ":current");
    })
    .then(function(version) {
      request.version = version;
    })
    .then(function() {
      return get(path + ":content-type:" + request.version);
    })
    .then(function(contentType) {
      request.contentType = contentType
      res.writeHead(200, { "Content-Type": request.contentType });
    })
    .then(function() { return new Promise(function(resolve, reject) {
      client.readStream(argv.prefix + path + ":" + request.version)
        .pipe(res)
        .on('finish', resolve)
        .on('error', reject);
    })})
    .then(function() {
      console.log("GET " + path + ":" + request.version + " 200 (" + request.contentType + ")");
    })
    .catch(function(error) {
      console.log("GET " + path + ":" + request.version + " 404 not found " + error.redis);
      res.status(error.code).send(error.message);
    })
});

app.listen(argv.port);

console.log("Listening for requests on port " + argv.port + "\n");
